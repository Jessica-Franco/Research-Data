# -*- coding: utf-8 -*-
"""Copia de predictor12Junio.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aCNVCvloXveiucSJOFldlhOskJdpv3J7
"""

# Importar Google Drive
from google.colab import drive
drive.mount('/content/drive')

import tensorflow as tf
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import confusion_matrix, classification_report
from imblearn.over_sampling import ADASYN  # Importar ADASYN
import matplotlib.pyplot as plt

# Establecer semilla para reproducibilidad
tf.random.set_seed(30)

# Ruta de los datos para abrir desde GoogleColab
file_path = '/content/drive/MyDrive/INVESTIGACIÓN DOCTORADO/promedio_promedios_abril03.xlsx'
df = pd.read_excel(file_path)

# Carga las etiquetas de frecuencia emocional
frecuencias_emocionales = df[["Angry", "Contempt", "Disgusted", "Happy", "Neutral", "Sad", "Scared", "Surprised"]]

# Carga las etiquetas de desempeño
desempeno = df["Desempeño"]

# Normalizar los datos
scaler = StandardScaler()
etiquetas_normalized = scaler.fit_transform(frecuencias_emocionales)

# Aplicar ADASYN para balancear las clases con una proporción específica
adasyn = ADASYN(sampling_strategy={1:520, 0:520})  # Ajustar los valores según sea necesario
etiquetas_resampled, desempeno_resampled = adasyn.fit_resample(etiquetas_normalized, desempeno)

# Dividir los datos para entrenar y probar
X_train, X_test, y_train, y_test = train_test_split(etiquetas_resampled, desempeno_resampled, test_size=0.2, random_state=30)

# Definir el modelo usando la API funcional de Keras
from tensorflow.keras.layers import Input, Dense, BatchNormalization
from tensorflow.keras.models import Model

inputs = Input(shape=(8,), name='InputLayer')
x = BatchNormalization()(inputs)
x = Dense(256, activation='relu', kernel_regularizer=tf.keras.regularizers.L2(0.006))(x)
x = BatchNormalization()(x)
x = Dense(128, activation='relu', kernel_regularizer=tf.keras.regularizers.L2(0.006))(x)
x = BatchNormalization()(x)
x = Dense(64, activation='relu', kernel_regularizer=tf.keras.regularizers.L2(0.006))(x)
x = BatchNormalization()(x)
x = Dense(32, activation='relu', kernel_regularizer=tf.keras.regularizers.L2(0.006))(x)
x = BatchNormalization()(x)
outputs = Dense(1, activation='sigmoid')(x)

model = Model(inputs=inputs, outputs=outputs)

# Compilar el modelo
model.compile(loss="binary_crossentropy", optimizer=tf.keras.optimizers.Adam(), metrics=["accuracy"])

# Entrenar el modelo con regularización L2
history = model.fit(X_train, y_train, epochs=1000, batch_size=64, validation_data=(X_test, y_test), verbose=0)

# Evaluación del modelo
loss, accuracy = model.evaluate(X_test, y_test)
print(f'\nTest Loss: {loss:.4f}, Test Accuracy: {accuracy:.4f}')

# Predicciones en el conjunto de prueba
y_pred = model.predict(X_test).flatten()

# Crear un DataFrame para comparar los resultados
resultados = pd.DataFrame({'Real': y_test.values, 'Predicción': (y_pred > 0.5).astype(int)})

# Mostrar la tabla de resultados
print(resultados)

# Mostrar la matriz de confusión y el informe de clasificación
conf_matrix = confusion_matrix(y_test, (y_pred > 0.5).astype(int))
class_report = classification_report(y_test, (y_pred > 0.5).astype(int))

print("Matriz de Confusión:")
print(conf_matrix)
print("\nInforme de Clasificación:")
print(class_report)
plt.savefig('/content/drive/MyDrive/INVESTIGACIÓN DOCTORADO/informe_clasificacion.pdf')  # Ruta para guardar el archivo PDF

from sklearn.metrics import roc_curve, auc

# Calcular la curva ROC
fpr, tpr, thresholds = roc_curve(y_test, y_pred)
roc_auc = auc(fpr, tpr)
plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'Área bajo la curva (AUC) = {roc_auc:.2f}')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlabel('Tasa de Falsos Positivos (FPR)')
plt.ylabel('Tasa de Verdaderos Positivos (TPR)')
plt.title('Curva ROC')
plt.legend()
plt.savefig('/content/drive/MyDrive/INVESTIGACIÓN DOCTORADO/curva_roc.pdf')  # Ruta para guardar el archivo PDF

plt.figure(figsize=(12, 4))
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()

plt.savefig('/content/drive/MyDrive/INVESTIGACIÓN DOCTORADO/precision_perdida.pdf')  # Ruta donde deseas guardar el archivo PDF

model.summary()

import matplotlib.pyplot as plt
import seaborn as sns

# Calcular la cantidad de muestras en cada clase antes y después de aplicar ADASYN
cantidad_clase_original = desempeno.value_counts().sort_index()
cantidad_clase_resampled = desempeno_resampled.value_counts().sort_index()

# Calcular el límite superior para el eje Y
maximo_muestras = max(cantidad_clase_original.max(), cantidad_clase_resampled.max())

# Graficar la distribución de clases antes de aplicar ADASYN
plt.figure(figsize=(12, 8))  # Aumentado el tamaño del recuadro
plt.subplot(1, 2, 1)
sns.countplot(x=desempeno, palette='Set2')
plt.ylim(0, maximo_muestras + 15)  # Establecer límites en el eje Y con espacio adicional
plt.title('Distribución de clases antes de ADASYN')
plt.xlabel('Clase')
plt.ylabel('Cantidad de muestras')

# Agregar números a las barras en el interior (antes de ADASYN)
for index, value in enumerate(cantidad_clase_original):
    plt.text(index, value, str(value), ha='center', va='bottom')

# Graficar la distribución de clases después de aplicar ADASYN
plt.subplot(1, 2, 2)
sns.countplot(x=desempeno_resampled, palette='Set2')
plt.ylim(0, maximo_muestras + 15)  # Establecer límites en el eje Y con espacio adicional
plt.title('Distribución de clases después de ADASYN')
plt.xlabel('Clase')
plt.ylabel('Cantidad de muestras')

# Agregar números a las barras en el interior (después de ADASYN)
for index, value in enumerate(cantidad_clase_resampled):
    plt.text(index, value, str(value), ha='center', va='bottom')

plt.tight_layout()
plt.show()
plt.savefig('/content/drive/MyDrive/INVESTIGACIÓN DOCTORADO/distribucion_clases_ADASYN.pdf')  # Ruta donde deseas guardar el archivo PDF